(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-0a026cf2"],{"2c20":function(e,t,i){},"2ed3":function(e,t,i){"use strict";i("2c20")},a6e4:function(e){e.exports=JSON.parse('{"vueQuestions":[{"title":"vue","question":"MVVM的理解","answer":["MVVM是一种软件架构模式，MVVM 分为 Model、View、ViewModel：","Model代表数据模型，数据和业务逻辑都在Model层中定义；","View代表UI视图，负责数据的展示；","ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；","Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。"]},{"title":"vue","question":"vue和react的区别，有什么相同","answer":["不同：","模版语法不同，react采用JSX语法，vue使用基于HTML的模版语法","数据绑定不同，vue 使用双向数据绑定，react 则需要手动控制组件的状态和属性。","状态管理不同，vue使用vuex状态管理，react使用redux状态管理","组件通信不同，vue使用props和事件的方式进行父子组件通信，react则通过props和回调函数的方式进行通信。","生命周期不同，vue有8个生命周期钩子，react有10个","响应式原理不同，vue使用双向绑定来实现数据更新，react则通过单向数据流来实现","相同：","组件化开发：Vue 和 React 都采用了组件化开发的方式，将用户界面划分为独立、可复用的组件，从而使代码更加模块化、可维护和可扩展。","虚拟 DOM：Vue 和 React 都使用虚拟 DOM 技术，通过在 JavaScript 和真实 DOM 之间建立一个轻量级的虚拟 DOM 层，实现高效的 DOM 更新和渲染。","响应式更新：Vue 和 React 都支持响应式更新，即当数据发生变化时，会自动更新相关的组件和视图，以保持用户界面的同步性。","集成能力：Vue 和 React 都具有良好的集成能力，可以与其他库和框架进行整合，例如 Vue 可以与 Vuex、Vue Router 等配套使用，React 可以与 Redux、React Router 等配套使用。"]},{"title":"vue","question":"Vue2和Vue3有哪些区别","answer":["Vue2使用的是optionsAPI ，Vue3使用composition API，更好的组织代码，提高代码可维护性","Vue3使用Proxy代理实现了新的响应式系统，比Vue2有着更好的性能和更准确的数据变化追踪能力。","Vue3引入了Teleprot组件，可以将DOM元素渲染到DOM数的其他位置，用于创建模态框、弹出框等。","Vue3全局API名称发生了变化，同时新增了watchEffect、Hooks等功能","Vue3对TypeScript的支持更加友好","Vue3核心库的依赖更少，减少打包体积","3支持更好的Tree Shanking，可以更加精确的按需要引入模块"]},{"title":"vue","question":"SPA的理解，有什么优缺点","answer":["SPA（单页应用）是一种前端应用程序的架构模式，它通过在加载应用程序时只加载单个 HTML 页面，并通过使用 JavaScript 动态地更新页面内容，从而实现无刷新的用户体验。"]},{"title":"vue","question":"SPA和多页面有什么区别","answer":["区别","页面加载方式：在多页面应用中，每个页面都是独立的 HTML 文件，每次导航时需要重新加载整个页面。而在 SPA 中，初始加载时只加载一个 HTML 页面，后续的导航通过 JavaScript 动态地更新页面内容，无需重新加载整个页面。","用户体验：SPA 提供了流畅、快速的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。","代码复用：SPA 通常采用组件化开发的方式，可以在不同的页面中复用组件，提高代码的可维护性和可扩展性。多页面应用的每个页面都是独立的，组件复用的机会较少。","路由管理：在多页面应用中，页面之间的导航和路由由服务器处理，每个页面对应一个不同的 URL。而在 SPA 中，前端负责管理页面的导航和路由，通过前端路由库（如 React Router 或 Vue Router）来管理不同路径对应的组件。","SEO（搜索引擎优化）：由于多页面应用的每个页面都是独立的 HTML 文件，搜索引擎可以直接索引和抓取每个页面的内容，有利于搜索引擎优化。相比之下，SPA 的内容是通过 JavaScript 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容，需要采取额外的优化措施。","服务器负载：SPA 只需初始加载时获取 HTML、CSS 和 JavaScript 文件，后续的页面更新和数据获取通常通过 API 请求完成，减轻了服务器的负载。而多页面应用每次导航都需要从服务器获取整个页面的内容。","优点","用户体验：SPA 提供了流畅、快速的用户体验，在页面加载后，只有需要的数据和资源会被加载，减少了页面刷新的延迟。","响应式交互：由于 SPA 依赖于异步数据加载和前端路由，可以实现实时更新和动态加载内容，使用户可以快速地与应用程序交互。","代码复用：SPA 通常采用组件化开发的方式，提高了代码的可维护性和可扩展性。","服务器负载较低：由于只有初始页面加载时需要从服务器获取 HTML、CSS 和 JavaScript 文件，减轻了服务器的负载。","缺点：","首次加载时间：SPA 首次加载时需要下载较大的 JavaScript 文件，这可能导致初始加载时间较长。","SEO（搜索引擎优化）问题：由于 SPA 的内容是通过 JavaScript 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容。","内存占用：SPA 在用户浏览应用程序时保持单个页面的状态，这可能导致较高的内存占用。","安全性：由于 SPA 通常使用 API 进行数据获取，因此需要特别注意安全性。"]},{"title":"vue","question":"Vue的性能优化有哪些","answer":["编码阶段","v-if和v-for不一起使用","v-for保证key的唯一性","使用keep-alive缓存组件","v-if和v-show酌情使用","路由懒加载、异步组件","图片懒加载","节流防抖","第三方模块按需引入","服务端与渲染","打包优化","压缩代码","使用CDN加载第三方模块","抽离公共文件","用户体验","骨架屏","客户端缓存","SEO优化","预渲染","服务端渲染","合理使用 meta 标签"]},{"title":"vue","question":"Vue生命周期","answer":["创建前后：","beforeCreate（创建前）： 数据观测和初始化事件还未开始，不能访问data、computed、watch、methods上的数据方法。","created(创建后)：实例创建完成，可以访问data、computed、watch、methods上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。","挂载前后：","beforeMount（挂载前）: Vue实例还未挂在到页面HTML上，此时可以发起服务器请求","mounted（挂载后）:Vue实例已经挂在完毕，可以操作DOM","更新前后：","beforeUpdate（更新前）: 数据更新之前调用，还未渲染页面","updated（更新后）:DOM重新渲染，此时数据和界面都是新的。","销毁前后：","beforeDestorye（销毁前）:实例销毁前调用，这时候能够获取到this","destoryed（销毁后）:实例销毁后调用，实例完全被销毁。"]},{"title":"vue","question":"常用的属性、指令有哪些","answer":["属性：","data：用于定义组件的初始数据。","props：用于传递数据给子组件。","computed：用于定义计算属性。","methods：用于定义组件的方法。","watch：用于监听组件的数据变化。","components：用于注册子组件。可以通过 components 属性将其他组件注册为当前组件的子组件，从而在模板中使用这些子组件。","指令：","v-if：条件渲染指令，根据表达式的真假来决定是否渲染元素。","v-show：条件显示指令，根据表达式的真假来决定元素的显示和隐藏。","v-for：列表渲染指令，用于根据数据源循环渲染元素列表。","v-bind：属性绑定指令，用于动态绑定元素属性到 Vue 实例的数据。","v-on：事件绑定指令，用于监听 DOM 事件，并执行对应的 Vue 方法。","v-model：双向数据绑定指令，用于在表单元素和 Vue 实例的数据之间建立双向绑定关系。","v-text：文本插值指令，用于将数据插入到元素的文本内容中。","v-html：HTML 插值指令，用于将数据作为 HTML 解析并插入到元素中。"]},{"title":"vue","question":"Computed 和 Watch 的区别","answer":["computed计算属性，通过对已有的属性值进行计算得到一个新值。它需要依赖于其他的数据，当数据发生变化时，computed会自动计算更新。computed属性值会被缓存，只有当依赖数据发生变化时才会重新计算，这样可以避免重复计算提高性能。","watch用于监听数据的变化，并在变化时执行一些操作。它可以监听单个数据或者数组，当数据发生变化时会执行对应的回调函数，和computed不同的是watch不会有缓存。"]},{"title":"vue","question":"Vue组件通信","answer":["父传子: [props,$children,$refs]","子传父: [$emit,$parent]","兄弟组件: [provied,inject,eventBus,Vuex]"]},{"title":"vue","question":"常见的事件修饰符及其作用","answer":[".stop阻止冒泡",".prevent阻止默认事件",".capture ：与事件冒泡的方向相反，事件捕获由外到内；",".self ：只会触发自己范围内的事件，不包含子元素；",".once：只会触发一次。"]},{"title":"vue","question":"v-if和v-show的区别","answer":["v-if元素不可见，直接删除DOM，有更高的切换消耗。 v-show通过设置元素display: none控制显示隐藏，更高的初始渲染消耗。"]},{"title":"vue","question":"v-html 的原理","answer":["会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。"]},{"title":"vue","question":"v-model 是如何实现的，语法糖实际是什么？","answer":["Vue 中数据双向绑定是一个指令v-model，可以绑定一个响应式数据到视图，同时视图的变化能改变该值。","当作用在表单上：通过v-bind:value绑定数据，v-on:input来监听数据变化并修改value","当作用在组件上：本质上是一个父子通信语法糖，通过props和$emit实现。"]},{"title":"vue","question":"data为什么是一个函数而不是对象","answer":["因为对象是一个引用类型，如果data是一个对象的情况下会造成多个组件共用一个data，data为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。"]},{"title":"vue","question":"mixin 和 mixins 区别","answer":["mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。","mixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。"]},{"title":"vue","question":"路由的hash和history模式的区别","answer":["hash模式 开发中默认的模式，地址栏URL后携带#，后面为路由。 原理是通过onhashchange()事件监听hash值变化，在页面hash值发生变化后，window就可以监听到事件改变，并按照规则加载相应的代码。hash值变化对应的URL都会被记录下来，这样就能实现浏览器历史页面前进后退。","history模式 history模式中URL没有#，这样相对hash模式更好看，但是需要后台配置支持。","history原理是使用HTML5 history提供的pushState、replaceState两个API，用于浏览器记录历史浏览栈，并且在修改URL时不会触发页面刷新和后台数据请求。"]},{"title":"vue","question":"router和route的区别","answer":["$route 是路由信息，包括path、params、query、name等路由信息参数","$router 是路由实例，包含了路由跳转方法、钩子函数等"]},{"title":"vue","question":"如何设置动态路由","answer":["params传参","路由配置： /index/:id","路由跳转：this.$router.push({name: \'index\', params: {id: \\"zs\\"}});","路由参数获取：$route.params.id","最后形成的路由：/index/zs","query传参","路由配置：/index正常的路由配置","路由跳转：this.$rouetr.push({path: \'index\', query:{id: \\"zs\\"}});","路由参数获取：$route.query.id","最后形成的路由：/index?id=zs","区别","获取参数方式不一样，一个通过$route.params，一个通过 $route.query","参数的生命周期不一样，query参数在URL地址栏中显示不容易丢失，params参数不会在地址栏显示，刷新后会消失"]},{"title":"vue","question":"路由守卫","answer":["全局前置钩子：beforeEach、beforeResolve、afterEach","路由独享守卫：beforeEnter","组件内钩子：beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave"]},{"title":"vue","question":"Vue中key的作用","answer":["key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，减少DOM操作量，提高性能。"]},{"title":"vue","question":"为什么不建议用index作为key?","answer":["如果将数组下标作为key值，那么当列表发生变化时，可能会导致key值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致Vue重新渲染整个列表。"]},{"title":"vue","question":"为什么v-for和v-if不能一起使用","answer":["v-for比v-if优先级更高，一起使用的话每次渲染列表时都要执行一次条件判断，造成不必要的计算，影响性能。"]},{"title":"vue","question":"双向数据绑定的原理","answer":["采用数据劫持结合发布者-订阅者模式的方式，data数据在初始化的时候，会实例化一个Observe类，在它会将data数据进行递归遍历，并通过Object.defineProperty方法，给每个值添加上一个getter和一个setter。在数据读取的时候会触发getter进行依赖（Watcher）收集，当数据改变时，会触发setter，对刚刚收集的依赖进行触发，并且更新watcher通知视图进行渲染。"]},{"title":"vue","question":"使用 Object.defineProperty() 来进行数据劫持有什么缺点？","answer":["该方法只能监听到数据的修改，监听不到数据的新增和删除，从而不能触发组件更新渲染。vue2中会对数组的新增删除方法push、pop、shift、unshift、splice、sort、reserve通过重写的形式，在拦截里面进行手动收集触发依赖更新。"]},{"title":"vue","question":"Vue2和Vue3相比有什么区别？","answer":["Vue3采用了Proxy代理的方式，Proxy是ES6引入的一个新特性，它提供了一个用于创建代理对象的构造函数。它是对整个对象的监听和拦截，可以对对象所有操作进行处理。而Object.defineProperty只能监听单个属性的读写，无法监听新增、删除等操作。"]},{"title":"vue","question":"Vue是如何收集依赖的？","answer":["依赖收集发生在defineReactive()方法中，在方法内new Dep()实例化一个Dep()实例，然后在getter中通过dep.depend()方法对数据依赖进行收集，然后在settter中通过dep.notify()通知更新。整个Dep其实就是一个观察者，吧收集的依赖存储起来，在需要的时候进行调用。在收集数据依赖的时候，会为数据创建一个Watcher，当数据发生改变通知每个Watcher，由Wathcer进行更新渲染。"]},{"title":"vue","question":"slot是什么？有什么作用？原理是什么？","answer":["slot插槽，一般在封装组件的时候使用，在组件内不知道以那种形式来展示内容时，可以用slot来占据位置，最终展示形式由父组件以内容形式传递过来，主要分为三种：","默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。","具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。","作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。","实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。"]},{"title":"vue","question":"对keep-alive的理解，它是如何实现的，具体缓存的是什么？","answer":["keep-alive是Vue.js的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。","include 字符串或正则表达式，只有名称匹配的组件会被匹配；","exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；","max 数字，最多可以缓存多少组件实例。","2 个生命周期 activated ， deactivated","activated：当缓存的组件被激活时，该钩子函数被调用。可以在该钩子函数中进行一些状态恢复、数据更新等操作。","deactivated：当缓存的组件被停用时，该钩子函数被调用。可以在该钩子函数中进行一些状态保存、数据清理等操作。","keep-alive内部其实是一个函数式组件，没有template标签。在render中通过获取组件的name和include、exclude进行匹配。匹配不成功，则不需要进行缓存，直接返回该组件的vnode。","匹配成功就进行缓存，获取组件的key在cache中进行查找，如果存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）也就实现了max功能。","不存在的话，就需要对组件进行缓存。将当前组件push(key)添加到尾部，然后再判断当前缓存的max是否超出指定个数，如果超出直接将第一个组件销毁（缓存淘汰策略LRU）。"]},{"title":"vue","question":"$nextTick 原理及作用","answer":["Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。 nextTick是将回调函数放到一个异步队列中，保证在异步更新DOM的watcher后面，从而获取到更新后的DOM。","因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。"]},{"title":"vue","question":"Vue模版编译原理","answer":["模版编译主要过程：template ---\x3e ast ---\x3e render，分别对象三个方法","parse 函数解析 template","optimize 函数优化静态内容","generate 函数创建 render 函数字符串","调用parse方法，将template转化为AST（抽象语法树），AST定义了三种类型，一种html标签，一种文本，一种插值表达式，并且通过 children 这个字段层层嵌套形成了树状的结构。","optimize方法对AST树进行静态内容优化，分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化。","generate将AST抽象语法树编译成 render字符串，最后通过new Function(render)生成可执行的render函数"]},{"title":"vue","question":"Vuex 的原理","answer":["Vuex是专门为Vue设计的状态管理，当Vue从store中读取数据后，数据发生改变，组件中的数据也会发生变化。 ","Vue Components 负责接收用户操作交互行为，执行dispatch触发对应的action进行回应","dispatch唯一能执行action的方法","action用来接收components的交互行为，包含异步同步操作","commit对mutation进行提交，唯一能执行mutation的方法","mutation唯一可以修改state状态的方法","state页面状态管理容器，用于存储状态","getters读取state方法","Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新。"]},{"title":"vue","question":"Vuex中action和mutation的区别","answer":["mutation更专注于修改state，必须是同步执行。","action提交的是mutation，而不是直接更新数据，可以是异步的，如业务代码，异步请求。","action可以包含多个mutation"]},{"title":"vue","question":"Vuex 和 localStorage 的区别","answer":["Vuex存储在内存中，页面关闭刷新就会消失。而localstorage存储在本地，读取内存比读取硬盘速度要快","Vuex应用于组件之间的传值，localstorage主要用于不同页面之间的传递","Vuex是响应式的，localstorage需要刷新"]},{"title":"vue","question":"对虚拟DOM的理解","answer":["虚拟DOM就是用JS对象来表述DOM节点，是对真实DOM的一层抽象。可以通过一些列操作使这个棵树映射到真实DOM上。","如在Vue中，会把代码转换为虚拟DOM，在最终渲染到页面，在每次数据发生变化前，都会缓存一份虚拟DOM，通过diff算法来对比新旧虚拟DOM记录到一个对象中按需更新，最后创建真实DOM，从而提升页面渲染性能。"]},{"title":"vue","question":"虚拟DOM就一定比真实DOM更快吗","answer":["虚拟DOM不一定比真实DOM更快，而是在特定情况下可以提供更好的性能。","在复杂情况下，虚拟DOM可以比真实DOM操作更快，因为它是在内存中维护一个虚拟的DOM树，将真实DOM操作转换为对虚拟DOM的操作，然后通过diff算法找出需要更新的部分，最后只变更这部分到真实DOM就可以。在频繁变更下，它可以批量处理这些变化从而减少对真实DOM的访问和操作，减少浏览器的回流重绘，提高页面渲染性能。","而在一下简单场景下，直接操作真实DOM可能会更快，当更新操作很少或者只是局部改变时，直接操作真实DOM比操作虚拟DOM更高效，省去了虚拟DOM的计算、对比开销。"]},{"title":"vue","question":"虚拟DOM的解析过程","answer":["首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。","当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。","最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。"]},{"title":"vue","question":"DIFF算法原理","answer":["diff的目的是找出差异，最小化的更新视图。 diff算法发生在视图更新阶段，当数据发生变化的时候，diff会对新旧虚拟DOM进行对比，只渲染有变化的部分。","对比是不是同类型标签，不是同类型直接替换","如果是同类型标签，执行patchVnode方法，判断新旧vnode是否相等。如果相等，直接返回。","新旧vnode不相等，需要比对新旧节点，比对原则是以新节点为主，主要分为以下几种。","newVnode 和 oldVnode都有文本节点，用新节点替换旧节点。","newVnode有子节点，oldVnode没有，新增newVnode的子节点。","newVnode没有子节点，oldVnode有子节点，删除oldVnode中的子节点。","newVnode和oldVnode都有子节点，通过updateChildren对比子节点。","双端diff","updateChildren方法用来对比子节点是否相同，将新旧节点同级进行比对，减少比对次数。会创建4个指针，分别指向新旧两个节点的首尾，首和尾指针向中间移动。","每次对比下两个头指针指向的节点、两个尾指针指向的节点，头和尾指向的节点，是不是 key是一样的，也就是可复用的。如果是重复的，直接patch更新一下，如果是头尾节点，需要进行移动位置，结果以新节点的为主。","如果都没有可以复用的节点，就从旧的vnode中查找，然后进行移动，没有找到就插入一个新节点。","当比对结束后，此时新节点还有剩余，就批量增加，如果旧节点有剩余就批量删除。"]}],"jsQuestion":[{"title":"js","question":"js数据类型有哪些","answer":["JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。","其中 Symbol 和 BigInt 是ES6 中新增的数据类型：","Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。","BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。","这些数据可以分为原始数据类型和引用数据类型（复杂数据类型），他们在内存中的存储方式不同。","堆： 存放引用数据类型，引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，如Object、Array、Function。","栈： 存放原始数据类型，栈中的简单数据段，占据空间小，属于被频繁使用的数据，如String、Number、Null、Boolean。"]},{"title":"js","question":"null和undefined区别","answer":["Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。","undefined 代表的含义是未定义，一般变量声明了但还没有定义的时候会返回 undefined，typeof为undefined","null 代表的含义是空对象，null主要用于赋值给一些可能会返回对象的变量，作为初始化，typeof为object"]},{"title":"js","question":"instanceof 运算符的实现原理及实现","answer":["instanceof运算符适用于检测构造函数的prototype属性上是否出现在某个实例对象的原型链上","instanceof 运算符的原理是基于原型链的查找。当使用 obj instanceof Constructor 进行判断时，JavaScript 引擎会从 obj 的原型链上查找 Constructor.prototype 是否存在，如果存在则返回 true，否则继续在原型链上查找。如果查找到原型链的顶端仍然没有找到，则返回 false。","instanceof运算符只能用于检查某个对象是否是某个构造函数的实例，不能用于基本类型的检查，如string、number等"]},{"title":"js","question":"typeof 和 instanceof 区别","answer":["typeof与instanceof 都是判断数据类型的方法，区别如下：","typeof会返回一个运算数的基本类型，instanceof 返回的是布尔值","instanceof 可以准确判断引用数据类型，但是不能正确判断原始数据类型","typeof虽然可以判断原始数据类型（null 除外），但是无法判断引用数据类型（function 除外）"]},{"title":"js","question":"那为什么typeof判断null为object？","answer":["这是 JavaScript 语言的一个历史遗留问题，在第一版JS代码中用32位比特来存储值，通过值的1-3位来识别类型，前三位为000表示对象类型。而null是一个空值，二进制表示都为0，所以前三位也就是000，所以导致 typeof null 返回 \\"object\\""]},{"title":"js","question":"为什么0.1+0.2 ! == 0.3，如何让其相等","answer":["因为浮点数运算的精度问题。在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。 因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成0.30000000000000004，所以在计算时会产生误差。","解决方案","将其先转换成整数，再相加之后转回小数。具体做法为先乘10相加后除以10","使用number对象的toFixed方法，只保留1位小数点。"]},{"title":"js","question":"判断数组的方式有哪些","answer":["通过Object.prototype.toString.call()做判断","Object.prototype.toString.call(obj).slice(8,-1) === \'Array\';","通过原型链做判断","obj.__proto__ === Array.prototype;","通过ES6的Array.isArray()做判断","Array.isArrray(obj);","通过instanceof做判断","obj instanceof Array"]},{"title":"js","question":"对类数组对象的理解，如何转化为数组","answer":["类数组也叫伪数组，类数组和数组类似，但不能调用数组方法，常见的类数组有arguments、通过document.getElements获取到的内容等，这些类数组具有length属性。","转换方法","通过 call 调用数组的 slice 方法来实现转换","Array.prototype.slice.call(arrayLike)","通过 call 调用数组的 splice 方法来实现转换","Array.prototype.splice.call(arrayLike, 0)","通过 apply 调用数组的 concat 方法来实现转换","Array.prototype.concat.apply([], arrayLike)","通过 Array.from 方法来实现转换","Array.from(arrayLike)","Array.propotype.slice.call()是什么 比如Array.prototype.slice.call(arguments)这句里，就是把 arguments 当做当前对象。","也就是说 要调用的是 arguments 的 slice 方法，而typeof arguments=\\"Object\\" 而不是 Array","它没有slice这个方法，通过这么Array.prototype.slice.call调用，JS的内部机制应该是 把arguments对象转化为Array"]},{"title":"js","question":"数组有哪些原生方法？","answer":["数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","数组首部操作的方法 shift() 和 unshift() ","重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和forEach()方法","数组归并方法 reduce() 和 reduceRight() 方法","改变原数组的方法：fill()、pop()、push()、shift()、splice()、unshift()、reverse()、sort()；","不改变原数组的方法：concat()、every()、filter()、find()、findIndex()、forEach()、indexOf()、join()、lastIndexOf()、map()、reduce()、reduceRight()、slice()、some()。"]},{"title":"js","question":"substring和substr的区别","answer":["它们都是字符串方法，用于截取字符串的一部分，主要区别在于参数不同","substring(startIndex, endIndex)： 接收两个参数，一个起始索引和结束索引，来指定字符串范围，如果省略第二个参数，则截取到字符串末尾。","substr(startIndex, length)： 接收两个参数，并返回从 startIndex 开始，长度为 length 的子字符串。如果省略第二个参数，则截取到字符串末尾。"]},{"title":"js","question":"object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别","answer":["都是浅拷贝","Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。","扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。"]},{"title":"js","question":"new操作符的实现原理","answer":["new操作符用来创建一个对象，并将该对象绑定到构造函数的this上。","new操作符的执行过程：","创建一个空对象","设置原型，将构造函数的原型指向空对象的 prototype 属性。","将 this 指向这个对象，通过apply执行构造函数。","判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象"]},{"title":"js","question":"for...in和for...of的区别","answer":["for...in和for...of都是JavaScript中的循环语句，而for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下","for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；","for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；","对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。"]},{"title":"js","question":"如何使用for...of遍历对象","answer":["为什么不能遍历对象","for…of是作为ES6新增的遍历方式，能被其遍历的数据内部都有一个遍历器iterator接口，而数组、字符串、Map、Set内部已经实现，普通对象内部没有，所以在遍历的时候会报错。想要遍历对象，可以给对象添加一个Symbol.iterator属性，并指向一个迭代器即可","在迭代器里面，通过Object.keys获取对象所有的key，然后遍历返回key 、value。"]},{"title":"js","question":"对AJAX的理解，实现一个AJAX请求","answer":["AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 创建AJAX请求的步骤：","创建一个 XMLHttpRequest 对象。","在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。","在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。","当对象的属性和监听函数设置完成后，最后调用 send 方法来向服务器发起请求，可以传入参数作为发送的数据体。"]},{"title":"js","question":"ajax、axios、fetch的区别","answer":["ajax","基于原生XHR开发，XHR本身架构不清晰。","针对MVC编程，不符合现在前端MVVM的浪潮。","多个请求之间如果有先后关系的话，就会出现回调地狱","配置和调用方式非常混乱，而且基于事件的异步模型不友好。","axios","支持PromiseAPI","从浏览器中创建XMLHttpRequest","从 node.js 创建 http 请求","支持请求拦截和响应拦截","自动转换JSON数据","客服端支持防止CSRF/XSRF","fetch","浏览器原生实现的请求方式，ajax的替代品","基于标准 Promise 实现，支持async/await","fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理","默认不会带cookie，需要添加配置项","fetch没有办法原生监测请求的进度，而XHR可以。"]},{"title":"js","question":"forEach和map方法有什么区别","answer":["两个方法都是用来遍历循环数组，区别如下：","forEach()对数据的操作会改变原数组，该方法没有返回值；","map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；"]},{"title":"js","question":"什么是尾调用，使用尾调用有什么好处？","answer":["尾调用就是在函数的最后一步调用函数，在一个函数里调用另外一个函数会保留当前执行的上下文，如果在函数尾部调用，因为已经是函数最后一步，所以这时可以不用保留当前的执行上下文，从而节省内存。但是ES6的尾调用只能在严格模式下开启，正常模式是无效的。"]},{"title":"js","question":"你用过哪些设计模式","answer":["单例模式：保证类只有一个实例，并提供一个访问它的全局访问点。","工厂模式：用来创建对象，根据不同的参数返回不同的对象实例。","策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。","装饰器模式：在不改变对象原型的基础上，对其进行包装扩展。","观察者模式：定义了对象间一种一对多关系，当目标对象状态发生改变时，所有依赖它对对象都会得到通知。","发布订阅模式： 基于一个主题/事件通道，希望接收通知的对象通过自定义事件订阅主题，被激活事件的对象（通过发布主题事件的方式被通知)。"]},{"title":"js","question":"如何实现深浅拷贝","answer":["深拷贝","JSON.stringify() 将js对象序列化，再通过JSON.parse反序列","如果对象中有函数、undefined、symbol时，都会丢失","如果有正则表达式、Error对象等，会得到空对象","浅拷贝","Object.assign() 拷贝对象","扩展运算符"]},{"title":"js","question":"let、const、var的区别","answer":["块级作用域： 块作用域由 { }包裹，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：","内层变量可能覆盖外层变量","用来计数的循环变量泄露为全局变量","变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。","给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。","重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。","初始值设置： 在变量声明时，var 和let可以不用设置初始值。而const声明变量必须设置初始值。","暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。"]},{"title":"js","question":"箭头函数与普通函数的区别","answer":["箭头函数是匿名函数，不能作为构造函数，使用new关键字。","箭头函数没有arguments","箭头函数没有自己的this，会获取所在的上下文作为自己的this","call()、applay()、bind()方法不能改变箭头函数中的this指向","箭头函数没有prototype","箭头函数不能用作Generator函数，不能使用yeild关键字"]},{"title":"js","question":"Set、Map的区别","answer":["Set","创建： new Set([1, 1, 2, 3, 3, 4, 2])","add(value)：添加某个值，返回Set结构本身。","delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。","has(value)：返回一个布尔值，表示该值是否为Set的成员。","clear()：清除所有成员，没有返回值。","Map","set(key, val): 向Map中添加新元素","get(key): 通过键值查找特定的数值并返回","has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false","delete(key): 通过键值从Map中移除对应的数据","clear(): 将这个Map中的所有元素删除","区别","Map是一种键值对的集合，和对象不同的是，键可以是任意值","Map可以遍历，可以和各种数据格式转换","Set是类似数组的一种的数据结构，类似数组的一种集合，但在Set中没有重复的值"]},{"title":"js","question":"map和Object的区别","answer":["map和Object都是用键值对来存储数据，区别如下：","键的类型：Map 的键可以是任意数据类型（包括对象、函数、NaN 等），而 Object 的键只能是字符串或者 Symbol 类型。","键值对的顺序：Map中的键值对是按照插入的顺序存储的，而对象中的键值对则没有顺序。","键值对的遍例：Map 的键值对可以使用 for...of 进行遍历，而 Object 的键值对需要手动遍历键值对。","继承关系：Map 没有继承关系，而 Object 是所有对象的基类。"]},{"title":"js","question":"map和weakMap的区别","answer":["它们是 JavaScript 中的两种不同的键值对集合，主要区别如下：","map的键可以是任意类型，weakMap键只能是对象类型。","map 使用常规的引用来管理键和值之间的关系，因此即使键不再使用，map 仍然会保留该键的内存。weakMap 使用弱引用来管理键和值之间的关系，因此如果键不再有其他引用，垃圾回收机制可以自动回收键值对。"]},{"title":"js","question":"说说你对Promise的理解","answer":["Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了地狱回调。","Promise的实例有三个状态:","Pending（初始状态）","Fulfilled（成功状态）","Rejected（失败状态）","Promise的实例有两个过程：","pending -> fulfilled : Resolved（已完成）","pending -> rejected：Rejected（已拒绝）","注意：一旦从进行状态变成为其他状态就永远不能更改状态了，其过程是不可逆的。","Promise构造函数接收一个带有resolve和reject参数的回调函数。","resolve的作用是将Promise状态从pending变为fulfilled，在异步操作成功时调用，并将异步结果返回，作为参数传递出去","reject的作用是将Promise状态从pending变为rejected，在异步操作失败后，将异步操作错误的结果，作为参数传递出去","Promise的缺点：","无法取消 Promise，一旦新建它就会立即执行，无法中途取消。","如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。","当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。"]},{"title":"js","question":"Promise方法","answer":["promise.then() 对应resolve成功的处理","promise.catch()对应reject失败的处理","promise.all()可以完成并行任务，将多个Promise实例数组，包装成一个新的Promise实例，返回的实例就是普通的Promise。有一个失败，代表该Primise失败。当所有的子Promise完成，返回值时全部值的数组","promise.race()类似promise.all()，区别在于有任意一个完成就算完成","promise.allSettled() 返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的promise 结果。"]},{"title":"js","question":"promise.all 和 promise.allsettled 区别","answer":["Promise.all() 和 Promise.allSettled() 都是用来处理多个 Promise 实例的方法，它们的区别在于以下几点：","all: 只有当所有Promise实例都resolve后，才会resolve返回一个由所有Promise返回值组成的数组。如果有一个Promise实例reject，就会立即被拒绝，并返回拒绝原因。all是团队的成功才算，如果有一个人失败就算失败。","allSettled： 等所有Promise执行完毕后，不管成功或失败， 都会吧每个Promise状态信息放到一个数组里面返回。"]},{"title":"js","question":"对async/await 的理解","answer":["async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。通过async关键字声明一个异步函数， await 用于等待一个异步方法执行完成，并且会阻塞执行。","async 函数返回的是一个 Promise 对象，如果在函数中 return 一个变量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。如果没有返回值，返回 Promise.resolve(undefined)"]},{"title":"js","question":"async/await对比Promise的优势","answer":["代码可读性高，Promise虽然摆脱了回掉地狱，但自身的链式调用会影响可读性。","相对Promise更优雅，传值更方便。","对错误处理友好，可以通过try/catch捕获，Promise的错误捕获⾮常冗余"]},{"title":"js","question":"谈谈你对ES6的理解","answer":["解构赋值","扩展运算符","箭头函数","模版字符串","Set、Map集合","新增class类","Proxy","Promise"]},{"title":"js","question":"ES6模块和CommonJS模块有什么区别","answer":["语法不同：ES6 模块使用 import 和 export 关键字来导入和导出模块，而 CommonJS 模块使用 require 和 module.exports 或 exports 来导入和导出模块。","异步加载: ES6 模块支持动态导入（dynamic import），可以异步加载模块。这使得在需要时按需加载模块成为可能，从而提高了性能。CommonJS 模块在设计时没有考虑异步加载的需求，通常在模块的顶部进行同步加载。"]},{"title":"js","question":"原型","answer":["prototype : js通过构造函数来创建对象，每个构造函数内部都会一个原型prototype属性，它指向另外一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。","proto: 当使用构造函数创建一个实例对象后，可以通过__proto__访问到prototype属性。","constructor：实例对象通过这个属性可以访问到构造函数"]},{"title":"js","question":"原型链","answer":["每个实例对象都有一个__proto__属性指向它的构造函数的原型对象，而这个原型对象也会有自己的原型对象，一层一层向上，直到顶级原型对象null，这样就形成了一个原型链。","当访问对象的一个属性或方法时，当对象身上不存在该属性方法时，就会沿着原型链向上查找，直到查找到该属性方法位置。","原型链的顶层原型是Object.prototype，如果这里没有就只指向null"]},{"title":"js","question":"实现寄生组合继承","answer":["利用Object.create()方法，将子类的原型指向父类，实现继承父类的方法属性，修改时也不影响父类。"]},{"title":"js","question":"对闭包的理解已经它的使用场景","answer":["闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。","闭包优点：","创建全局私有变量，避免变量全局污染","可以实现封装、缓存等","闭包缺点：","创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出","解决： 在不需要使用的时候把变量设为null","使用场景：","用于创建全局私有变量","封装类和模块","实现函数柯里化"]},{"title":"js","question":"闭包一定会造成内存泄漏吗？","answer":["闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。"]},{"title":"js","question":"对作用域、作用域链的理解","answer":["作用域是一个变量或函数的可访问范围，作用域控制着变量或函数的可见性和生命周期。","全局作用域：可以全局访问","最外层函数和最外层定义的变量拥有全局作用域","window上的对象属性方法拥有全局作用域","为定义直接复制的变量自动申明拥有全局作用域","过多的全局作用域变量会导致变量全局污染，命名冲突","函数作用域：只能在函数中访问使用哦","在函数中定义的变量，都只能在内部使用，外部无法访问","内层作用域可以访问外层，外层不能访问内存作用域","ES6中的块级作用域：只在代码块中访问使用","使用ES6中新增的let、const什么的变量，具备块级作用域，块级作用域可以在函数中创建（由{}包裹的代码都是块级作用域）","let、const申明的变量不会变量提升，const也不能重复申明","块级作用域主要用来解决由变量提升导致的变量覆盖问题","作用域链： 变量在指定的作用域中没有找到，会依次向一层作用域进行查找，直到全局作用域。这个查找的过程被称为作用域链。"]},{"title":"js","question":"call() 、bind（）、 apply() 的区别？","answer":["都可以用作改变this指向","call和apply的区别在于传参，call、bind都是传入对象。apply传入一个数组。","call、apply改变this指向后会立即执行函数，bind在改变this后返回一个函数，不会立即执行函数，需要手动调用。"]},{"title":"js","question":"连续多个 bind，最后this指向是什么？","answer":["在 JavaScript 中，连续多次调用 bind 方法，最终函数的 this 上下文是由第一次调用 bind 方法的参数决定的"]},{"title":"js","question":"事件冒泡事件委托原理？","answer":["事件冒泡就是事件从最深的节点开始,然后逐步向上传播事件。这个过程叫事件冒泡","通俗的来讲就是：触发子元素身上的事件也可以触发父元素身上同等类型事件。","阻止事件冒泡event.stopPropagation();","阻止事件默认行为event.preventDefault();","事件委托：利用事件冒泡的原理，把事件加到父元素上，触发执行效果。","优点：","减少内存消耗，提高性能","动态绑定事件","缺点：","事件委托不是真正的委托，只是利用事件冒泡的原理，把事件加到父元素上，触发执行效果。"]},{"title":"js","question":"浏览器的垃圾回收机制","answer":["垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。​如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。","在 V8 中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象：","Major GC(主垃圾回收器)：主要负责老生代垃圾的回收","内存占用比较小","Minor GC(副垃圾回收器)：主要负责新生代垃圾的回收","对象的占用空间大 对象存活时间长","新生代（副垃圾回收器）","副垃圾回收器主要负责新⽣代的垃圾回收。大多数的对象最开始都会被分配在新生代，该存储空间相对较小，分为两个空间：from 空间（对象区）和 to 空间（空闲区）。","新增变量会放到To空间，当空间满后需要执行一次垃圾清理操作","对垃圾数据进行标记，标记完成后将存活的数据复制到From空间中，有序排列","交换两个空间，原来的To变成From，旧的From变成To","老生代（主垃圾回收器）","主垃圾回收器主要负责⽼⽣代中的垃圾回收。存储一些占用空间大、存活时间长的数据，采用标记清除算法进行垃圾回收。","主要分为标记、清除两个阶段。","标记：将所有的变量打上标记0，然后从根节点(window对象、DOM树等)开始遍历，把存活的变量标记为1","清除：清除标记为0的对象，释放内存。清除后将1的变量改为0，方便下一轮回收。","对⼀块内存多次执⾏标记清除算法后，会产⽣⼤量不连续的内存碎⽚。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜引⼊了另外⼀种算法——标记整理。","标记整理的标记过程仍然与标记清除算法⾥的是⼀样的，先标记可回收对象，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有存活的对象都向⼀端移动，然后直接清理掉这⼀端之外的内存。","引用计数法","个对象被引用一次，引用数就+1，反之就-1。当引用为0，就会出发垃圾回收。","这种方式会产生一个问题，在循环引用时，引用数永远不会为0，无法回收。"]},{"title":"js","question":"哪些情况会导致内存泄漏","answer":["意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。","闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。"]}],"htmlCssQuestion":[{"title":"htmlCss","question":"src和href的区别","answer":["src和href都是用来加载外部资源，区别如下","src当浏览器解析到该元素时，会暂停其他资源的加载和处理，直到该资源加载完成。 它会将资源内容嵌入到当前标签所在的位置，将其指向的资源下载应用到文档内，如js脚本等。常用在img、script、iframe等标签。","href指向外部资源所在的位置，和当前元素位置建立链接，当浏览器解识别到它指向的位置，将其下载的时候不会阻止其他资源的加载解析。常用在a 、 link标签。"]},{"title":"htmlCss","question":"HTML5新增特性","answer":["新增语义化标签，head、footer、nav、main、section等","新增表单类型属性，email、number、时间控件、color颜色拾取器、placeholder、autofocus自动获取焦点...","新增音视频标签，video、audio","新增canvas画布、websocket通信、拖拽等","新增本地存储localStorage、sessionStorage"]},{"title":"htmlCss","question":"对HTML语义化理解","answer":["根据内容来选择合适的标签","方便搜索引擎更好的识别内容。","有利于代码可读性，开发者能清晰的看出网页的结构，便于团队的开发与维护。"]},{"title":"htmlCss","question":"DOCTYPE(⽂档类型) 的作⽤","answer":["DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，是用来告诉浏览器的解析器，该用什么样的方式去加载识别文档。"]},{"title":"htmlCss","question":"iframe 有那些优点和缺点？","answer":["iframe通常用来加载外部链接，不会影响网页内容的加载。","优点","可以将网页原封不动的加载进来","增加代码的可用性","用来加载显示较慢的内容，如广告、视频等","缺点","加载的内容无法被浏览器引擎识别，对SEO不友好","会阻塞onload事件加载","会产生很多页面，不利于管理"]},{"title":"htmlCss","question":"Canvas和SVG的区别","answer":["canvas画布，是通过javascript来绘制图形，是逐像素进行渲染。","SVG矢量图，是基于XML描述的2D图形语言，每个元素都是可用的，可以为其添加事件。"]},{"title":"htmlCss","question":"script标签中defer和async的区别","answer":["他俩都是表示异步加载外部JS脚本，不会阻碍页面的加载解析。 区别","执行顺序：有多个async标签不能保证先后加载顺序，而多个defer标签可以按先后顺序加载。","是否立即执行：async加载完脚本后会立即执行，defer是要等文档解析完成后才执行。"]},{"title":"htmlCss","question":"行内元素、块级元素、空（void）","answer":["行内： a、b、span、input、img、select、 strong","块：p、div、h1、ul、ol、li、dl、dt、dd","空：<hr>、<br>、<img>、<input>、<link>、<meta>"]},{"title":"htmlCss","question":"怎样添加、移除、移动、复制、创建和查找节点","answer":["添加节点document.appendChild(dom)","移除节点document.removeChild(dom)","移动节点document.appendChild(targetDom)","复制节点dom.cloneNode(true)，参数true表示是否复制子节点","创建节点document.createElement(dom)","查找节点：","document.getElementById(\\"elementId\\")","document.getElementsByClassName(\\"className\\")","document.getElementsByTagName(\\"tagName\\")","document.querySelector(\\"selector\\")","document.querySelectorAll(\\"selector\\")"]},{"title":"htmlCss","question":"CSS3新增特性","answer":["新增CSS选择器、伪类","特效：text-shadow、box-shadow","线性渐变: gradient","旋转过渡：transform、transtion","动画: animation","圆角: border-radius"]},{"title":"htmlCss","question":"盒模型","answer":["盒模型都是由四个部分组成的，分别是margin、border、padding和content。","标准盒模型和IE盒模型的区别在于设置width和height时，对应的范围不同。","标准盒模型的width、height只包含了content","IE盒模型的的width、height除了content本身，还包含了border、padding","通过修改元素的box-sizing属性来改变元素的盒模型","box-sizeing: content-box表示标准盒模型（默认值）","box-sizeing: border-box表示IE盒模型（IE盒模型)"]},{"title":"htmlCss","question":"CSS选择器和优先级","answer":["选择器: [id选择器 #id, 类选择器 .classname, 属性选择器 div[class=\\"foo\\"], 伪类选择器 div::last-child, 标签选择器 div, 伪元素选择器 div:after, 兄弟选择器 div+span, 子选择器 ui>li, 后代选择器 div span, 通配符选择器]","优先级","!important","内联样式","ID选择器","类选择器/伪类选择器/属性选择器","标签选择器/伪元素选择器","关系选择器/通配符选择器"]},{"title":"htmlCss","question":"CSS可继承属性和不可继承属性","answer":["可继承: [font-weight, color，font-size，line-height，cursor]","不可继承：[margin，padding，border，display，background，overflow，width，height，position]"]},{"title":"htmlCss","question":"dislpay的属性和作用","answer":["block: 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。","inline: 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。","inline-block: 行内块级元素，默认宽度为内容宽度，可以设置宽高，同行显示","table: 块级表格","flex: flex容器布局","none: 隐藏元素","inherit: 从父元素继承display属性"]},{"title":"htmlCss","question":"隐藏元素的方式","answer":["display：none：元素在文档中不存在，不会占据位置。","visibility： hidden：元素在文档中的位置还保留，仍然占据空间。","opacity：0：将透明度设置为0。","z-index：负值：直接将元素放置在最下层，利用其他元素来遮盖。","position：absolute：将元素定位到可视区域以外。"]},{"title":"htmlCss","question":"单行、多行文本溢出","answer":["单行","overflow: hidden; // 溢出隐藏","text-overflow: ellipsis; // 溢出用省略号显示","whtie-space: nowrap; //规定段落中的文本不进行换行","多行","overflow:hidden","text-overflow: ellipsis;     // 溢出用省略号显示","display:-webkit-box;         // 作为弹性伸缩盒子模型显示。","-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列","-webkit-line-clamp:3;        // 显示的行数"]},{"title":"htmlCss","question":"有使用过Sass、Less 吗？他们的区别是什么？","answer":["他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 增加了 CSS代码的复用性，层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。 区别","编译环境不一样","Sass是在服务端处理的，以前是Ruby，现在是Dart-Sass或Node-Sass","而Less是需要引入less.js来处理Less代码输出CSS到浏览器，也可以在开发服务器将Less语法编译成css文件，输出CSS文件到生产包目录","变量符不一样，Less是@，而Scss是$。","Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持"]},{"title":"htmlCss","question":"link和@import的区别","answer":["link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性等","@import是CSS提供等语法规则，只有导入样式表带作用。","link标签引入的CSS被同时加载，而@import引入的CSS将在页面加载完毕后被加载","@import是CSS2.1才有的语法，存在兼容性，而link作为HTML标签不存在兼容性问题"]},{"title":"htmlCss","question":"常见的CSS单位","answer":["px像素","CSS像素","物理像素","百分比%，作用于父元素， 当浏览器的宽度或者高度发生变化时，当前元素依据比例发生变化。","em和rem，相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。","vw/vh是与视图窗口有关的单位，代表视图窗口的宽高。"]},{"title":"htmlCss","question":"px、em、rem的区别","answer":["px 固定像素单位，不能随其它元素的变化而变化","em是相对于父元素的单位，会随着父元素变化而变化","rem是相对于根元素html，它会随着html元素变化而变化"]},{"title":"htmlCss","question":"flex布局理解","answer":["flex布局是CSS3新增的一种布局方式，能够根据不同屏幕尺寸的变化来自适应大小。常用的属性：","flex-direction属性决定主轴的方向（即项目的排列方向）。","flex-wrap属性定义，如果一条轴线排不下，如何换行。","flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。","justify-content属性定义了项目在主轴上的对齐方式。","align-items属性定义项目在交叉轴上如何对齐。","align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。"]},{"title":"htmlCss","question":"什么是margin重叠，如何解决","answer":["两个块级元素分别设置上下margin时可能会导致边距合并为一个边距，合并到边距取最大的那个值。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。","计算规则","都是正数，取最大的。20px 40px ---\x3e 40px","一正一负，用正数减去负数后。20px -50px ---\x3e -30px","都是负数，用0减去两个中绝对值大的那个。-30px -10px ---\x3e -20px","解决方案 对于重叠的情况，主要有两种：兄弟之间重叠（margin合并） 和 父子之间重叠（margin塌陷）","兄弟之间重叠","底部元素变为行内盒子：display: inline-block","底部元素设置浮动：float","底部元素的position的值为absolute/fixed","父子之间重叠","父元素加入：overflow: hidden","父元素添加透明边框：border:1px solid transparent","子元素变为行内盒子：display: inline-block","子元素加入浮动属性或定位"]},{"title":"htmlCss","question":"position 常用属性 默认值是什么","answer":["static 默认值，没有定位，元素正常在文档流中显示","relative 相对定位，相对于原来的位置进行定位","absolute 绝对定位，相对于static定位意外以外的一个父元素进行定位。","fixed 绝对定位，相对于浏览器窗口","sticky 粘性定位，基于用户滚动位置"]},{"title":"htmlCss","question":"实现一个三角形","answer":["通过设置不同方向边框来实现","width: 0;","height: 0;","border-top: 50px solid red;","border-right: 50px solid transparent;","border-left: 50px solid transparent;"]},{"title":"htmlCss","question":"画一条0.5px的线","answer":["使用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","采用meta viewport的方式，这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果。"]},{"title":"htmlCss","question":"如何解决1px","answer":["1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。","直接写0.5px","利用伪元素，先放大再缩小","使用viewport缩放来解决"]}],"webpackQuestion":[{"title":"工程化","question":"常用的git命令","answer":["git clone：克隆远程仓库到本地。","git init：在当前目录初始化一个新的Git仓库。","git add ：将文件添加到暂存区，准备提交。","git commit -m \\"commit_message\\"：提交暂存区的改动到本地仓库，附带提交信息。","git status：查看工作区、暂存区的状态，显示文件的修改情况。","git diff：显示工作区与暂存区之间的差异。","git diff --staged：显示暂存区与最后一次提交之间的差异。","git log：显示提交日志，包括提交哈希、作者、日期等信息。","git branch：列出所有分支，当前分支前会有一个星号。","git checkout ：切换到指定分支。","git checkout -b ：创建并切换到新分支。","git merge ：将指定分支合并到当前分支。","git pull ：拉取远程仓库的更新并合并到当前分支。","git push ：将本地分支的更新推送到远程仓库。"]},{"title":"工程化","question":"git rebase和git merge的区别","answer":["git rebase 和 git merge 都是用于合并分支的 Git 命令，这两个命令都能将一个分支合并到另一个分支，但两者合并方式有很大不同","git merge: 将一个分支的更改合并到另一个分支，创建一个新的merge commit，将两个分支的历史合并在一起，这个merge commit会在分支历史中保留，可以清晰的看到那些分支合并到了柱分枝，合并后形成分叉结构。","git rebase：两个分支在合并到时候，会将整个分支和合并到另一个分支的顶端。首先找到两个分支的共同commit记录，然后提取之后所有的commit，然后将这个commit记录添加到另一个分支的最前面，两个分支合并后的commit记录就变成线性记录"]},{"title":"工程化","question":"webpack配置有哪些","answer":["entry：入口文件","output：输出文件配置","resolve：用来配置模块的解析方式","module：用来配置模块如何被解析","plugins：插件","devServer：开发服务器配置","devtool：调试工具","optimization：优化相关配置","externals：外部扩展的配置","performance：性能相关配置","target：构建的目标环境"]},{"title":"工程化","question":"有哪些常见的 Loader 和 Plugin？","answer":["image-loader : 加载并且压缩图片文件","css-loader : 加载 CSS，支持模块化、压缩、文件导入等特性","style-loader : 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS","eslint-loader : 通过 ESLint 检查 JavaScript 代码","tslint-loader : 通过 TSLint检查 TypeScript 代码","babel-loader : 把 ES6 转换成 ES5","define-plugin : 定义环境变量","html-webpack-plugin : 简化 HTML 文件创建","webpack-parallel-uglify-plugin : 多进程执行代码压缩，提升构建速度","webpack-bundle-analyzer : 可视化 Webpack 输出文件的体积","speed-measure-webpack-plugin : 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)","mini-css-extract-plugin : 分离样式文件，CSS 提取为独立文件，支持按需加载"]},{"title":"工程化","question":"那你再说一说Loader和Plugin的区别？","answer":["Loader本质是一个函数，它是一个转换器。webpack只能解析原生js文件，对于其他类型文件就需要用loader进行转换。","Plugin它是一个插件，用于增强webpack功能。webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。","Loader的配置是在module.rules下进行。类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ）","Plugin的配置在plugins下。类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。"]},{"title":"工程化","question":"webpack的构建流程","answer":["初始化参数：从配置文件或者shell语句中读取合并参数","开始编译：用参数初始化Compiler对象，加载所有配置的插件，执行run方法。","确定入口：根据entry参数找到入口文件","编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；","完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；","输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；","输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统","总结就是三个阶段：","初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler","编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理","输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中"]},{"title":"工程化","question":"什么是Webpack的热更新（Hot Module Replacement）？原理是什么？","answer":["Webpack的热更新（Hot Module Replacement，简称HMR），在不刷新页面的前提下，将新代码替换掉旧代码。","HRM的原理实际上是 webpack-dev-server（WDS）和浏览器之间维护了一个websocket服务。当本地资源发生变化后，webpack会先将打包生成新的模块代码放入内存中，然后WDS向浏览器推送更新，并附带上构建时的hash，让客户端和上一次资源进行对比。客户端对比出差异后会向WDS发起Ajax请求获取到更改后的内容（文件列表、hash），通过这些信息再向WDS发起jsonp请求获取到最新的模块代码。"]},{"title":"工程化","question":"bundle，chunk，module是什么？","answer":["bundle 捆绑包： 它是构建过程的最终产物，由说有需要的chunk和module组成。","chunk 代码块：一个chunk由多个模块组合而成，用于代码的合并和分割，在构建过程中一起被打包到一个文件中。","module 模块：是代码的基本单位，可以是一个文件、一个组件、一个库等。在编译的时候会从entry中递归寻找出所有依赖的模块。"]},{"title":"工程化","question":"什么是Code Splitting？","answer":["Code Splitting代码分割，是一种优化技术。它允许将一个大的chunk拆分成多个小的chunk，从而实现按需加载，减少初始加载时间，并提高应用程序的性能。","通常Webopack会将所有代码打包到一个单独的bundle中，然后在页面加载时一次性加载整个bundle。这样的做法可能导致初始加载时间过长，尤其是在大型应用程序中，因为用户需要等待所有代码加载完成才能访问应用程序。","Code Splitting 解决了这个问题，它将应用程序的代码划分为多个代码块，每个代码块代表不同的功能或路由。这些代码块可以在需要时被动态加载，使得页面只加载当前所需的功能，而不必等待整个应用程序的所有代码加载完毕。","在Webpack中通过optimization.splitChunks配置项来开启代码分割。"]},{"title":"工程化","question":"Webpack的Source Map是什么？如何配置生成Source Map？","answer":["Source Map是一种文件，它建立了构建后的代码与原始源代码之间的映射关系。通常在开发阶段开启，用来调试代码，帮助找到代码问题所在。","可以在Webpack配置文件中的devtool选项中指定devtool: \'source-map\'来开启。"]},{"title":"工程化","question":"如何提高webpack的打包速度","answer":["利用缓存：利用Webpack的持久缓存功能，避免重复构建没有变化的代码。可以使用cache: true选项启用缓存。","使用多进程/多线程构建 ：使用thread-loader、happypack等插件可以将构建过程分解为多个进程或线程，从而利用多核处理器加速构建。","使用DllPlugin和HardSourceWebpackPlugin： DllPlugin可以将第三方库预先打包成单独的文件，减少构建时间。HardSourceWebpackPlugin可以缓存中间文件，加速后续构建过程。","使用Tree Shaking: 配置Webpack的Tree Shaking机制，去除未使用的代码，减小生成的文件体积","移除不必要的插件: 移除不必要的插件和配置，避免不必要的复杂性和性能开销。"]},{"title":"工程化","question":"如何减少打包后的代码体积","answer":["代码分割（Code Splitting）：将应用程序的代码划分为多个代码块，按需加载。这可以减小初始加载的体积，使页面更快加载。","Tree Shaking：配置Webpack的Tree Shaking机制，去除未使用的代码。这可以从模块中移除那些在项目中没有被引用到的部分。","压缩代码：使用工具如UglifyJS或Terser来压缩JavaScript代码。这会删除空格、注释和不必要的代码，减小文件体积。","使用生产模式：在Webpack中使用生产模式，通过设置mode: \'production\'来启用优化。这会自动应用一系列性能优化策略，包括代码压缩和Tree Shaking。","使用压缩工具：使用现代的压缩工具，如Brotli和Gzip，来对静态资源进行压缩，从而减小传输体积。","利用CDN加速：将项目中引用的静态资源路径修改为CDN上的路径，减少图片、字体等静态资源等打包。"]},{"title":"工程化","question":"vite比webpack快在哪里","answer":["他们都是前端构建工具，但vite构建速度相对于webpack还是有一些速度优势","冷启动速度：vite是利用浏览器的原生ES moudle，采用按需加载的当时，而不是将整个项目打包。而webpack是将整个项目打包成一个或多个bundle，构建过程复杂。","HMR热更新： vite使用浏览器内置的ES模块功能，使得在开发模式下的热模块替换更加高效，那个文件更新就加载那个文件。它通过WebSocket在模块级别上进行实时更新，而不是像Webpack那样在热更新时重新加载整个包。","构建速度： 在生产环境下，Vite的构建速度也通常比Webpack快，因为Vite的按需加载策略避免了将所有代码打包到一个大文件中。而且，Vite对于缓存、预构建等方面的优化也有助于减少构建时间。","缓存策略： Vite利用浏览器的缓存机制，将依赖的模块存储在浏览器中，避免重复加载。这使得页面之间的切换更加迅速。","不需要预编译： Vite不需要预编译或生成中间文件，因此不会产生大量的临时文件，减少了文件IO操作，进一步提升了速度。"]}],"browserQuestion":[{"title":"浏览器","question":"XSS（跨站脚本攻击）","answer":["XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。","避免方式","不用服务器端拼接后返回（不使用服务端渲染）。","对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。","对用户输入的地方和变量都需要仔细检查长度和对 ”<”,”>”,”;”,”’” 等字符做过滤"]},{"title":"浏览器","question":"CSRF（跨站请求伪造）","answer":["CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。","避免方式","添加验证码验证","使用token验证","限制 cookie 不能作为被第三方使用","进行同源检测"]},{"title":"浏览器","question":"什么进程和线程？有什么区别","answer":["进程（Process）","进程是计算机中正在运行的程序的实例，一个进程就是一个程序运行实例。它拥有独立的内存空间、代码和数据，并且由操作系统负责调度和管理。每个进程在执行时都会分配独立的内存空间，不同进程之间的内存是隔离的，一个进程的错误不会直接影响其他进程。 进程之间通过进程间通信（IPC）机制来交换数据和进行通信，常见的IPC方式包括管道、消息队列、共享内存等。进程的切换开销较大，因为需要保存和恢复进程的完整状态，涉及到内存保护和虚拟内存的切换。","线程（Thread）","线程是进程的子任务，一个进程可以包含多个线程。它们共享相同的代码和数据，但拥有独立的执行栈和寄存器集合。多个线程可以在同一进程内并发执行，共享进程的资源，如内存空间、打开的文件等。线程间的通信和数据交换比进程间的通信更加方便，因为它们共享相同的地址空间。线程的切换开销较小，因为线程共享进程的地址空间，切换时不需要切换内存页表，速度较快。","区别","进程和线程都可以实现并发执行，但进程是独立的执行实体，而线程是依赖于进程的。","进程之间资源相互隔离，线程共享所属进程的资源。","创建和销毁线程的开销较小，而创建和销毁进程的开销较大。","多线程程序的编程复杂度通常比单线程程序高，但多线程可以更好地利用多核处理器来提高程序的执行效率。"]},{"title":"浏览器","question":"浏览器有哪些进程","answer":["主进程：负责处理用户输入、渲染页面等主要任务。","渲染进程：渲染进程负责解析HTML、CSS和JavaScript，并将网页渲染成可视化内容。","GPU进程：负责处理浏览器中的GPU加速任务。","网络线程：网络进程负责处理浏览器中的网络请求和响应，包括下载网页和资源等。","插件进程：负责浏览器插件运行。"]},{"title":"浏览器","question":"协商缓存和强缓存的区别","answer":["强缓存","使用强缓存策略时，如果缓存资源有效，浏览器会从本地读取缓存资源并返回200，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。","Expires指定资源的过期时间。在过期时间以内，改资源可以被缓存使用，不需要向浏览器发送请求。这个时间依赖于服务器时间，会存在服务器时间和客户端时间不一致。","Cache-Control属性：","private： 仅浏览器可以缓存","public：浏览器和代理服务器都可以缓存","max-age=xxx 过期时间，单位为秒","no-cache 不进行强缓存，但会有协商缓存","no-store 不强缓存，也不协商缓存","当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。","协商缓存","如果设置强缓存，无需发起请求，直接使用缓存内容。如果没有命中强缓存，设置了协商缓存，也不需要发起请求，使用缓存。","命中协商缓存条件：","Cache-Control: no-cache","max-age时间过期","在使用协商缓存时，会先向服务器发送一个请求，如果资源没有发生修改，则请求返回304状态，让浏览器使用本地缓存。如果资源发生修改，则返回修改后的内容","在request headers中的Etag属性和Last-Modified属性，来进行设置。其中，ETage优先于Last-Modified。","Etag文件改动 服务器在返回资源的时候，在头信息中添加Etag属性，这个属性是资源的唯一标识符。当资源改变，这个值也会改变。下次请求资源时，会在请求头中添加If-None-Match属性，为上一次请求的资源的Etag值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。这种方式比Last-Modified更加准确。","Last-Modified 上次修改时间 服务器通过在响应头上添加Last-Modified属性，来指出资源最后一次修改时间。当浏览器发起请求时，会在请求头上添加一个IF-Modified-Since属性，值为上一次资源请求的Last-Modified的值。服务区会通过这个属性和最后修改时间来进行比较，以此来判断资源是否修改。如果没有资源修改，返回304状态，使用本地缓存。如果资源修改，就返回最新资源，200状态。","这种方式有个缺点，Last-Modified标记的时间只能精确到1秒，如果文件在1秒内修改，但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。","区别","强缓存优先级高于协商缓存","协商缓存不论命中与否都会发送一次请求","强缓存返回200，协商缓存命中返回304","Ctrl+F5 会强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。"]},{"title":"浏览器","question":"为什么需要浏览器缓存？","answer":["使用浏览器缓存，有以下优点：","减少了服务器的负担，提高了网站的性能","加快了客户端网页的加载速度","减少了多余网络数据传输"]},{"title":"浏览器","question":"常见浏览器所用内核","answer":["IE浏览器内核，Trident 内核，也是俗称的IE内核；","Chrome 浏览器内核，以前是 Webkit 内核，现在是 Blink内核；","Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；","Safari 浏览器内核：Webkit 内核；","360浏览器、猎豹浏览器内核：IE + Chrome 双内核；"]},{"title":"浏览器","question":"浏览器的渲染过程","answer":["解析文档，生成DOM树","解析CSS，根据CSS规则生成CSSOM规则树","在CSSOM树和DOM树生成完后，合并DOM、CSSOM树构建渲染树","渲染树构建完成后，开始计算元素大小和位置【回流发生在这个阶段】","根据计算好的位置信息将内容渲染到屏幕上【重绘发生在这个阶段】"]},{"title":"浏览器","question":"浏览器渲染优化","answer":["优化javaScript，JavaScript会阻塞HTML的解析，改变JavaScrip加载方式。","将JavaScript放到body最后面","尽量使用异步加载JS资源，这样不会阻塞DOM解析，如defer、async","优化CSS加载，","CSS样式少，使用内嵌样式","导入外部样式使用link，而不是@import，因为它会阻塞渲染。","减少回流重绘","避免频繁操作样式","避免频繁操作DOM","复杂动画使用定位脱离文当流","使用transform替代动画"]},{"title":"浏览器","question":"Cookie、LocalStorage、SessionStorage区别","answer":["Cookie","大小只有4kb","跨域不能共享","不安全，容易被劫持","只存在请求头中","SessionStorage","存储在内存中，体积相对较大","页面关闭，数据会消失","相对Cookie安全","LocalStorage","体积大，可以存储更多内容。","生命周期长，除非手动删除，不然会一直存在","存储在硬盘中，不会像Cookie一样被请求携带"]},{"title":"浏览器","question":"什么是同源策略","answer":["跨域问题其实就是浏览器的同源策略造成的。 同源指的是：协议、端口号、域名必须一致。"]},{"title":"浏览器","question":"如何解决跨越问题","answer":["CORS：服务器开启跨域资源共享","JSONP：利用<script>标签不存在跨域限制，只支持GET请求，且不安全。","nginx代理跨域","nodejs 中间件代理跨域，通过node开启一个代理服务器。"]},{"title":"浏览器","question":"事件流","answer":["事件流分为三个阶段：捕获阶段、目标阶段、冒泡阶段。","过程如下：","捕获阶段：事件从最外层的节点，也就是文档对象开始，逐级向下传播，直到事件的目标节点上。","目标阶段：事件到达目标节点，触发目标节点上的事件处理函数。","冒泡阶段：事件从目标节点开始，逐级向上传播，直到到达最外层节点（文档对象）","事件冒泡和捕获的区别？","事件冒泡和事件捕获是两种不同的事件传播方式，默认是冒泡，它们的区别在于传播方向不同：","事件冒泡是从自下而上，从子元素冒泡到父元素，执行父元素上的事件处理。","事件捕获是事件从文档的根元素开始，逐级向下传播到较为具体的元素（即从父元素到子元素）。","如何阻止事件冒泡","普通浏览器：event.stopPropagation()","IE浏览器：event.cancelBubble = true;","对事件委托的理解","利用浏览器事件冒泡机制。事件在冒泡的过程中会传到父节点，并且父节点可以通过事件对象获取到目标节点，可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件"]},{"title":"浏览器","question":"回流与重绘","answer":["回流-当DOM变化影响了元素，比如元素的尺寸、布局、显示隐藏等改变了，需要重写构建。每个页面至少需要一次回流，就是在页面第一次加载的时候，这个时候一定会发生回流。","重绘-当一个元素的外观发生变化，但是没有改变布局，重新渲染元素的外观。比如background-color、color","如何避免回流重绘：","避免使用table布局","尽可能在DOM树的最末端改变class","不要频繁的操作元素的样式","避免设置多层内联样式","开启GPU加速","使用absolute或者fixed，脱离标准文档流","回流必将引起重绘，而重绘不一定会引起回流"]},{"title":"浏览器","question":"对浏览器事件循环的理解","answer":["事件循环是一种机制，它会不断的轮询任务队列，并将队列中的任务依此执行。","JavaScript的任务分为两种同步和异步：","同步任务：在主线程上排队执行的任务，只有一个任务执行完毕，才能执行下一个任务，","异步任务：不进入主线程，而是放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程执行调用栈的任务。","因为js是单线程，在执行代码的时候将所有函数压入执行栈中。同步任务会按照后进先出的原则以此执行。遇到异步任务时，将其放入任务队列中。当前执行栈里事件执行完毕后，就会从任务队列中取出对应异步任务的回调函数放入执行栈中继续执行。","宏观任务(MacroTask|Task)、微观任务(MicorTask)。","宏任务：script全部代码、setTimeout、setInterval、I/O、UI渲染","微任务：Promise.then、Process.nexTick(Node独有)、MutationObserver","任务队列中的任务分为宏任务和微任务，当执行栈清空后，会先检查任务队列中是否有微任务，如果有就按照先进先出的原则，压入执行栈中执行。微任务中产生了新的微任务不会推迟到下一个循环中，而是在当前循环中继续执行。 当执行这一轮的微任务完毕后，开启下一轮循环，执行任务队列中的宏任务。","一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。","执行顺序","执行宏任务中的同步代码，遇到宏任务或微任务，分别放入对应的任务队列，等待执行。","当所有同步任务执行完毕后，执行栈为空，首先执行微任务队列中的任务","微任务执行完毕后，检查这次执行中是否产生新的微任务，如果存在，重复执行步骤，直到微任务执行完毕。","开始下一轮Event Loop，执行宏任务中的代码"]},{"title":"浏览器","question":"Node和浏览器事件循环机制的区别","answer":["浏览器事件循环会在宏任务结束后，检查微任务。而Node的微任务是在两个阶段之间执行。","浏览器的process.nextTick和其他微任务优先级一样，而node中要高于其他优先级。"]},{"title":"浏览器","question":"Node.js的事件循环","answer":["Node事件循环分为6个阶段，每进入一个阶段，都会去对应的回调队列中取出函数执行。","Timers阶段：执行timer（setTimeout、setInterval）的回调，由poll阶段控制；","I/O callbacks阶段：系统调用相关的回调","idle prepare阶段：Nodejs内部执行，可以忽略","poll阶段：轮询 在该阶段如果没有timer的话，会出现一下情况","poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；","poll队列对空，会出现以下两种情况","如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调；","如果没有 setImmediate 回调需要执行，就会等待回调被天加到队列中，然后立即执行。 如果设置里有timer，并且 poll 队列为空，就会判断是否有 timer 超时，如果有就回到 timers 阶段执行回调。","check阶段：执行 setImmediate 回调","colse callbacks阶段：执行一些关闭回调，比如socket.on(\'close\', ...)等。","process.nextTick","它会在轮询的各个阶段结束时，进入到下一个阶段之前立即执行。","setImmediate 和 setTimeout","这种情况下，定时器的执行顺序是随机的。","如果把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用"]}],"netQuestion":[{"title":"网络","question":"GET和POST的请求的区别","answer":["传递的参数不同，POST传递的参数在request body中，GET传递的参数在url后拼接","GET请求一般用于查询，POST一般用于提交某种信息进行某些修改操作","POST相对GET请求安全","GET请求会被浏览器主动缓存，POST不会，要手动设置","GET请求长度有限制，POST没有"]},{"title":"网络","question":"POST和PUT请求的区别","answer":["PUT请求为更新数据","POST为创建数据"]},{"title":"网络","question":"HTTP和HTTPS协议的区别","answer":["HTTPS需要CA证书，HTTP不需要","HTTP是明文传输，不安全。而HTTPS基于SSL进行加密，相对安全。","HTTP端口为80，HTTPS端口443"]},{"title":"网络","question":"对 WebSocket 的理解","answer":["WebSocket 是一种在单个TCP 连接上实现全双工通信的网络协议，与传统的 HTTP 协议不同，HTTP是基于请求-响应模式，即客户端发送请求，服务器返回响应，然后连接关闭。而 WebSocket 允许客户端和服务器之间保持持久性的连接，双方可以随时互相发送数据，而不需要每次通信都建立新的连接。","服务器可以向客户端主动推送消息，客户端也可以主动向服务器推送消息。"]}]}')},b4c3:function(e,t,i){"use strict";i.r(t);var s=function(){var e=this,t=e._self._c;return t("div",{staticClass:"wrap"},[t("h1",{staticClass:"ac"},[e._v("Web 前端面试模拟")]),t("div",{staticClass:"ready ac"},[e.visible?e._e():t("el-button",{attrs:{type:"primary"},on:{click:e.init}},[e._v("模拟答题")]),e.visible?e._e():t("el-button",{attrs:{type:"primary"},on:{click:e.showAll}},[e._v("查看全部")])],1),e.visible?t("div",{staticClass:"question-list"},e._l(e.questions,(function(i,s){return t("el-card",{key:s},[t("div",{attrs:{slot:"header"},slot:"header"},[t("el-tag",{attrs:{size:"small"}},[e._v("["+e._s(i.title)+"]")]),e._v(" "),t("strong",[e._v(e._s(i.question))])],1),t("div",[t("div",{directives:[{name:"show",rawName:"v-show",value:i.show,expression:"item.show"}],staticClass:"answer"},e._l(i.answer,(function(i,s){return t("p",{key:s,staticClass:"answer-item"},[e._v(" "+e._s(i)+" ")])})),0),t("div",{staticClass:"ctrls text-right"},[i.show?e._e():t("el-button",{attrs:{type:"primary"},on:{click:function(e){i.show=!i.show}}},[e._v("查看答案")])],1)])])})),1):e._e(),e.visible?t("div",{staticClass:"refresh ac"},[e.visible?t("el-button",{attrs:{type:"primary"},on:{click:e.init}},[e._v("重新开始")]):e._e(),t("el-button",{attrs:{type:"primary"},on:{click:function(t){e.visible=!1}}},[e._v("关闭答题")])],1):e._e()])},o=[];i("14d9");const n=i("a6e4");var a={data(){return{visible:!1,questions:[]}},methods:{init(){this.questions=[];const e=[n.vueQuestions,n.jsQuestion,n.htmlCssQuestion,n.webpackQuestion,n.browserQuestion,n.netQuestion],t=[15,20,10,5,8,3],i=this.mergeRandomElementsFromArrays(e,t),s=i.map(e=>({...e,show:!1}));this.questions=s,window.scrollTo(0,0),this.visible=!0},showAll(){this.questions=[];const e=[...n.vueQuestions,...n.jsQuestion,...n.htmlCssQuestion,...n.webpackQuestion,...n.browserQuestion,...n.netQuestion],t=e.map(e=>({...e,show:!0}));this.questions=t,this.visible=!0},getRandomElementsFromArray(e,t){const i=e.slice(),s=[];for(let o=0;o<t;o++){if(0===i.length)break;const e=Math.floor(Math.random()*i.length);s.push(i.splice(e,1)[0])}return s},mergeRandomElementsFromArrays(e,t){let i=[];for(let s=0;s<e.length;s++){const o=e[s],n=t[s],a=this.getRandomElementsFromArray(o,n);i=i.concat(a)}return i}},mounted(){}},r=a,l=(i("2ed3"),i("2877")),u=Object(l["a"])(r,s,o,!1,null,"80bf9db4",null);t["default"]=u.exports}}]);